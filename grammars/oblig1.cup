package oblig1parser;
import java_cup.runtime.*;
import syntaxtree.*;
import syntaxtree.decl.*;
import syntaxtree.expr.*;
import syntaxtree.stmt.*;
import java.util.*;

parser code {:

:};
/* Keywords*/
terminal                        PROGRAM;
terminal                        CLASS;
terminal                        BEGIN;
terminal                        END;
terminal                        VAR;
terminal                        PROCEDURE;
terminal                        RETURN;
terminal                        REF;
terminal                        DEREF;
terminal                        IF, THEN, ELSE;
terminal                        WHILE, DO;
terminal                        NOT;
terminal                        NEW;
terminal			TRUE;
terminal			FALSE;

/* Constants */
terminal Boolean                BOOL;
terminal                        NULL;

/* Types */
terminal                        TYPE_BOOL;
terminal                        TYPE_INT;
terminal                        TYPE_STRING;
terminal                        TYPE_FLOAT;
terminal String                 ID;

/* Symbols */
terminal                        LPAR, RPAR;
terminal                        SEMI;
terminal                        COLON;
terminal                        DOT;
terminal                        COMMA;
terminal                        ASSIGN;
terminal                        LOG_AND;
terminal                        LOG_OR;
terminal                        REL_LT, REL_LTE, REL_GT, REL_GTE, REL_EQ, REL_NEQ;
terminal                        ARIT_PLUS, ARIT_MINUS, ARIT_MUL, ARIT_DIV, ARIT_POW;
terminal			COLON_EQUAL;

/* Identifiers */

/* Literals */
terminal Float                  FLOAT_LITERAL;
terminal String                 STRING_LITERAL;
terminal Integer                INT_LITERAL;


/* Nonterminals */
/* Misc */
non terminal Program            program;
non terminal Name               name;
non terminal Type               type;

/* Declarations */
non terminal Decl               decl;
non terminal VarDecl            var_decl;
non terminal ProcDecl           proc_decl;
non terminal ClassDecl          class_decl;
non terminal ParamDecl          param_decl;
non terminal List<Decl>         decl_list, opt_decl_list;
non terminal List<VarDecl>      var_list;
non terminal List<ParamDecl>    param_list;

/* Expressions */
non terminal Exp                exp;
non terminal List<Exp>      exprs_list;
non terminal BinaryExpr         binary_expr;
non terminal UnaryExpr          unary_expr;
non terminal LogOpExp           log_op_exp;
non terminal RelOpExp           rel_op_exp;
non terminal AritOpExp          arit_op_exp;

/* Statements */
non terminal Stmt               stmt;
non terminal IfStmt             if_stmt;
non terminal WhileStmt          while_stmt;
non terminal ReturnStmt         return_stmt;
non terminal CallStmt           call_stmt;
non terminal AssignStmt         assign_stmt;
non terminal List<Stmt>         stmt_list, opt_stmt_list;

/* Literals */
non terminal Literal            literal;
non terminal BoolLiteral        bool_literal;
non terminal FloatLiteral       float_literal;
non terminal IntLiteral         int_literal;
non terminal NullLiteral        null_literal;
non terminal StringLiteral      string_literal;

/*Precedence*/
precedence left LOG_OR;
precedence left LOG_AND;
precedence right NOT;
precedence left REL_LT, REL_LTE, REL_GT, REL_GTE, REL_EQ, REL_NEQ;
precedence left ARIT_PLUS, ARIT_MINUS;
precedence left ARIT_MUL, ARIT_DIV;
precedence right ARIT_POW;
precedence left DOT;


/* The grammar */

program         ::= PROGRAM ID:name BEGIN decl_list:dl END SEMI
                    {: RESULT = new Program(name, dl); :} ;

opt_decl_list   ::= decl_list:l {: RESULT = l; :}
                |   {: RESULT = new LinkedList<Decl>(); :};

decl_list       ::= decl:d SEMI {: List<Decl> l = new LinkedList<Decl>(); l.add(d); RESULT = l; :}
                |   decl_list:dl decl:d SEMI {: dl.add(d); RESULT = dl; :};

decl            ::= class_decl:sd {: RESULT = sd; :}
                |   var_decl:vd {: RESULT = vd; :}
                |   proc_decl:pd {: RESULT = pd; :};

stmt            ::= {: RESULT = new DummyStmt(); :};

class_decl      ::= CLASS ID:name BEGIN var_list:vl END
                    {: RESULT = new ClassDecl(name, vl); :}
                |   CLASS ID:name BEGIN END
                    {: RESULT = new ClassDecl(name); :};

var_list        ::= var_decl:v SEMI {: List<VarDecl> l = new LinkedList<VarDecl>(); l.add(v); RESULT = l; :}
                |   var_list:l var_decl:v SEMI {: l.add(v); RESULT = l; :};

var_decl        ::= VAR ID:name COLON type:t {: RESULT = new VarDecl(name, t); :};

proc_decl       ::= PROCEDURE ID:name LPAR param_list:pl RPAR COLON type:t BEGIN opt_decl_list:dl opt_stmt_list:sl END
                    {: RESULT = new ProcDecl(name, pl, dl, sl, t); :}
                | PROCEDURE ID:name LPAR param_list:pl RPAR BEGIN opt_decl_list:dl opt_stmt_list:sl END
                    {: RESULT = new ProcDecl(name, pl, dl, sl); :};

param_list      ::= param_decl:d {: List<ParamDecl> l = new LinkedList<ParamDecl>(); l.add(d); RESULT = l; :}
                |   param_list:pl COMMA param_decl:d {: pl.add(d); RESULT = pl; :}
                |   {: RESULT = new LinkedList<ParamDecl>(); :};

param_decl      ::= ID:name COLON type:t {: RESULT = new ParamDecl(name, t); :};

opt_stmt_list   ::= stmt_list:l {: RESULT = l; :}
                |   {: RESULT = new LinkedList<Stmt>(); :};

stmt_list       ::= stmt:s SEMI {: List<Stmt> l = new LinkedList<Stmt>(); l.add(s); RESULT = l; :}
                |   stmt_list:sl stmt:s SEMI {: sl.add(s); RESULT = sl; :};

type            ::= TYPE_FLOAT {: RESULT = new Type("float"); :}
                |   TYPE_INT {: RESULT = new Type("int"); :}
                |   TYPE_STRING {: RESULT = new Type("string"); :}
                |   TYPE_BOOL {: RESULT = new Type("bool"); :};

exp             ::= binary_expr:e {: RESULT = e; :}
                |   unary_expr:e {: RESULT = e; :};

binary_expr     ::= log_op_exp:e {: RESULT = e; :}
                |   rel_op_exp:e {: RESULT = e; :}
                |   arit_op_exp:e {: RESULT = e; :};

unary_expr      ::= NOT exp:e {: RESULT = new NotExpr(e); :}
                |   ID:v exp:e
                    {: RESULT = new VarExpr(v); RESULT = new VarExpr(v, e); /*can we have two results here?*/:}
                |   literal: l {: RESULT = new LiteralExpr(l); :}
/*what to do about call statement, keep it in exp or stmt?*/
                |   call_stmt:s {: RESULT = new CallStatementExpression(s); :}
                |   NEW name:name {: RESULT = new NewExpr(new Type(name)); :}
                |   REF exp:e {: RESULT = new RefExpr(e); :}
                |   DEREF exp:e {: RESULT = new DerefVarExpr(e); :}
                |   LPAR exp:e RPAR {: RESULT = new ParenthesesExpr(e); :};

literal         ::= FLOAT_LITERAL:f {: RESULT = new FloatLiteral(f); :}
                |   INT_LITERAL:i {: RESULT = new IntLiteral(i); :}
                |   STRING_LITERAL:s {: RESULT = new StringLiteral(s); :}
                |   TRUE {: RESULT = new BoolLiteral(true); :}
                |   FALSE {: RESULT = new BoolLiteral(false); :}
                |   NULL {: RESULT = new NullLiteral(); :};

log_op_exp      ::= exp:e1 LOG_AND exp:e2 {: RESULT = new LogOpExpr(e1, "&&", e2);    /*How to use AND*/ :}
                |   exp:e1 LOG_OR exp:e2 {: RESULT = new LogOpExpr(e1, "||", e2);    /*How to use OR*/:};

rel_op_exp      ::= exp:e1 REL_EQ exp:e2 {: RESULT = new RelOpExpr(e1, "=", e2); :}
                |   exp:e1 REL_NEQ exp:e2 {: RESULT = new RelOpExpr(e1, "<>", e2); :}
                |   exp:e1 REL_GT exp:e2 {: RESULT = new RelOpExpr(e1, ">", e2); :}
                |   exp:e1 REL_GTE exp:e2 {: RESULT = new RelOpExpr(e1, ">=", e2); :}
                |   exp:e1 REL_LT exp:e2 {: RESULT = new RelOpExpr(e1, "<", e2); :}
                |   exp:e1 REL_LTE exp:e2 {: RESULT = new RelOpExpr(e1, ""<=, e2); :};

arit_op_exp     ::= exp:e1 ARIT_PLUS exp:e2 {: RESULT = new AritOpExpr(e1, "+" , e2); :}
                |   exp:e1 ARIT_MINUS exp:e2 {: RESULT = new AritOpExpr(e1, "-" , e2); :}
                |   exp:e1 ARIT_MUL exp:e2 {: RESULT = new AritOpExpr(e1, "*" , e2); :}
                |   exp:e1 ARIT_DIV exp:e2 {: RESULT = new AritOpExpr(e1, "/", e2); :}
                |   exp:e1 ARIT_POW exp:e2 {: RESULT = new AritOpExpr(e1, "#" , e2); :};

name            ::= ID:id {: RESULT = new Name(id); :};

assign_stmt     ::= VAR:v COLON_EQUAL exp:e {: RESULT = new AssignStmt(v, e); :};

while_stmt      ::= WHILE exp:e DO LPAR opt_stmt_list:s RPAR {: RESULT = new WhileStmt(e, s); :};

/*if statement missing*/

return_stmt     ::= RETURN exp:e {: RESULT = new ReturnStmt(e); :}
                |   RETURN {: RESULT = new ReturnStmt(); :};

call_stmt       ::= name:name LPAR exprs_list:exprs RPAR {: RESULT = new CallStmt(name, exprs); :};


